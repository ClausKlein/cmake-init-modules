# CMake 3.30 is required for C++23 `import std` support; we use 3.29.20240416
# here so that in-development versions satisfy it.
cmake_minimum_required(VERSION 3.30 FATAL_ERROR)

# Set experimental flag to enable `import std` support from CMake.
# This must be enabled before C++ language support.
set(CMAKE_EXPERIMENTAL_CXX_IMPORT_STD
    # This specific value changes as experimental support evolves. See
    # `Help/dev/experimental.rst` in the CMake source corresponding to
    # your CMake build for the exact value to use.
    "0e5b6991-d74f-4b3d-a41c-cf096e0b2508"
)

# C++ needs to be enabled.
project(import_std LANGUAGES CXX)

# Tell CMake that we explicitly want `import std`. This will initialize the
# property on all targets declared after this to 1
set(CMAKE_CXX_MODULE_STD 1)

if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang" AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER_EQUAL 19.1)
    # set(USE_MODULES TRUE) # used by fmt
    set(CMAKE_CXX_SCAN_FOR_MODULES ON)
    # see https://releases.llvm.org/19.1.0/projects/libcxx/docs/index.html
    # and https://releases.llvm.org/19.1.0/projects/libcxx/docs/Modules.html
    # Currently CMake requires extensions enabled when using import std.
    # https://gitlab.kitware.com/cmake/cmake/-/issues/25916
    # https://gitlab.kitware.com/cmake/cmake/-/issues/25539
    set(CMAKE_CXX_EXTENSIONS ON)
    add_compile_options(-fexperimental-library)
    add_link_options(-lc++experimental)
    add_compile_options(-ftime-trace)
    add_compile_options(-stdlib=libc++)
    add_link_options(-stdlib=libc++)
    if(DEFINED ENV{LLVM_ROOT})
        message(STATUS "LLVM_ROOT=$ENV{LLVM_ROOT}")
        set(LLVM_LIBC_SOURCE $ENV{LLVM_ROOT}/share/libc++/v1)
        set(HAS_STDLIB_MODULES stdlib)
        set(CMAKE_CXX_COMPILER_IMPORT_STD 23)
    endif()
endif()

# Build the stdlib module
function(add_stdlib_module NAME)
    add_library(${NAME})
    add_library(__CMAKE::CXX23 ALIAS ${NAME})
    # cmake-format: off
    target_sources(${NAME} PUBLIC
        FILE_SET CXX_MODULES
        BASE_DIRS ${LLVM_LIBC_SOURCE}
        FILES
            ${LLVM_LIBC_SOURCE}/std.cppm
            ${LLVM_LIBC_SOURCE}/std.compat.cppm
    )
    # cmake-format: on
    target_compile_features(${NAME} PUBLIC cxx_std_23)
    target_compile_definitions(${NAME} PUBLIC _LIBCPP_HAS_NO_LOCALIZATION)
    target_compile_options(${NAME} PRIVATE -Wno-reserved-module-identifier)
endfunction()

# Build the stdlib module
if(HAS_STDLIB_MODULES)
    message(STATUS "HAS_STDLIB_MODULES=${HAS_STDLIB_MODULES}")
    # XXX add_stdlib_module(${HAS_STDLIB_MODULES})
endif()

#
# Import the modules from libc++
#

# include(FetchContent)
# FetchContent_Declare(
#   std
#   URL "file://${LIBCXX_BUILD}/modules/c++/v1/"
#   DOWNLOAD_EXTRACT_TIMESTAMP TRUE
#   SYSTEM
# )
# FetchContent_MakeAvailable(std)

# Make a library.
add_library(uses_std STATIC)
# Add sources.
target_sources(uses_std PRIVATE uses_std.cxx)
# Tell CMake we're using C++23 but only C++20 is needed to consume it.
target_compile_features(uses_std PRIVATE cxx_std_23 INTERFACE cxx_std_20)

# Make an executable.
add_executable(main)
# Note that this source is *not* allowed to `import std` as it ends up
# with only C++20 support due to the `uses_std` INTERFACE requirements.
target_sources(main PRIVATE main.cxx)
target_link_libraries(main PRIVATE uses_std)
